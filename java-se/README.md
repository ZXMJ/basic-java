# java核心技术卷一

## 第三章Java基本程序设计结构
-   Unicode和char类型
- 	位运算符(掩码技术)
- 	+=右结合运算符,有强制转换的功能
- 	strictfp和StrictMath
- 	字符串常量是共享的,而+或substring等操作产生的结果并不是共享的
- 	输入输出
- 	大数值

## 第四章类与对象
- 	类路径

## 第五章继承
- 	Objects
-   `数组和ArrayList区别与联系:泛型与多态`
-   `反射机制的实现:自己如何实现反射`
-   `继承后的问题:属性,方法,构造器;父类的私有方法,属性,构造函数,子类不能直接访问,可以通过父类提供的共有方法访问`

**意见建议**
-   使用多态,而非类型信息(if/else和多态)
- 	创建集合时确定集合长度,ensureCapacity,trimToSize

## 第六章接口,lambda表达式,内部类
- 	接口:解决多继承的问题,不能被实例化,所以不能有实例域,构造方法;方法可以有自己的默认实现,静态方法
- 	抽象类:解决子类共有和各自方法的实现
- 	类:面向对象编程的灵魂

### lambda表达式

- 	只有一个抽象方法的接口称为函数式接口(functional interface),可以提供一个lambda表达式,lambda表达式中不能改变变量

- 	函数式接口(functional interface),建议使用@FunctionalInterface注解来标记并约束这个接口

- 	方法引用:已经有现成的方法可以完成你想要传递到其他代码的某个动作

-   用::操作符分隔方法名与对象或类名.主要有3种情况

       1. object::instance Method;可以使用this,super作为目标
    
       2. Class::static Method
    
       3. Class::instance Method第1个参数会成为方法的目标

-  构造器引用:类型::new;eg:Integer::new.int[]::new

### 内部类




## 第8章泛型程序设计

-   泛型程序设计(Generic programming)意味着编写的代码可以被很多不同类型的对象所重用

-   使用泛型机制编写的程序代码要比那些杂乱地使用Object变量,然后再进行强制类型转换的代码具有更好的安全性和可读性;

-   泛型的实现:无限定(认为是限定为继承Object)和有限定类型的实现;(多限定)限定泛型

-   泛型类.泛型方法

-   类型变量限定:限定类型用&分隔,在Java的继承中,可以根据需要拥有多个接口超类型,但限定中至多有一个类如果用一个类作为限定,它必须是限定列表中的第一个

-   泛型代码和虚拟机:虚拟机没有泛型类型对象,所有对象都属于普通类

   - 类型擦除:擦除(erased)类型变量,并替换为第一个限定的类型(无限定的变量用Object)(class Interval<T extends Serializable&Comparable >如果这样做,
   原始类型用Serializable替换T 而编译器在必要时要向Comparable插入强制类型转换.为了提高效率,应该将标签(tagging)接口(即没有方法的接口)放在边界列表的末尾)

   - 翻译泛型表达式:程序调用泛型方法时,如果擦除返回类型,编译器插入强制类型转换

   - 翻译泛型方法: TODO 

   - 约束与局限性:大多数限制都是由类型擦除引起的
   
     - 不能用基本类型实例化类型参数
     - 运行时类型查询只适用于原始类型: a instanceof Pair<String>//Error
     - 不能创建参数化类型的数组:?
     - Varargs警告
     - 不能实例化类型变置
     - 不能构造泛型数组
     - 泛型类的静态上下文中类型变量无效
     - 不能抛出或捕获泛型类的实例
     - 可以消除对受查异常的检查
     - 注意擦除后的冲突

-   泛型类型的继承规则:无论S与T有什么联系,Pair<S>与Pair<T>没有什么联系.

-   通配符:允许类型参数变化

    带有超类型限定的通配符可以向泛型对象写入,带有子类型限定的通配符可以从泛型对象读取
   -  子类限定:extends;eg:Pair<? extends Employee>
   -  父类限定:super
   
无限定通配符:

## 第九章集合

链表:

数组列表:

散列集:散列表用链表数组实现;

   - 每个列表被称为桶(bucket).要想査找表中对象的位置,就要先计算它的散列码,然后与桶的总数取余, 所得到的结果就是保存这个元素的桶的索引

   - 散列冲突(hash collision):桶被占满;在JavaSE8中,桶满时会从链表变为平衡二叉树;散列函数不当或者恶意代码试图在散列表中填充多个有相同散列码的值,这样就能提高性能

   - 装填因子(load factor)决定何时对散列表进行再散列




继承,接口,内部类,代理,克隆,包装,视图,加密,掩码技术
